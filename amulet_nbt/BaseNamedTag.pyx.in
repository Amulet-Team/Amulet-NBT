{{py:
import re
CamelCaseMatch = re.compile(r"(?<!^)(?=[A-Z])")
}}
cdef class Named{{TAG_Name}}({{TAG_Name}}):
    def __init__(self, object value={{default_type}}, str name=""):
        super().__init__(value)
        self.name = name

    def to_nbt(
        self,
        *,
        bint compressed=True,
        bint little_endian=False,
        str name="",
    ):
        return super().to_nbt(
            compressed=compressed,
            little_endian=little_endian,
            name=name or self.name
        )

    def save_to(
        self,
        object filepath_or_buffer=None,
        *,
        bint compressed=True,
        bint little_endian=False,
        str name="",
    ):
        return super().save_to(
            filepath_or_buffer,
            compressed=compressed,
            little_endian=little_endian,
            name=name or self.name
        )

    @staticmethod
    cdef Named{{TAG_Name}} read_named_payload(BufferContext buffer, bint little_endian):
        cdef Named{{TAG_Name}} tag = Named{{TAG_Name}}.__new__(Named{{TAG_Name}})
        tag.name = read_string(buffer, little_endian)
        _read_{{CamelCaseMatch.sub("_", TAG_Name).lower()}}_payload(tag, buffer, little_endian)
        return tag

    def __eq__(self, other):
        if isinstance(other, {{TAG_Name}}) and super().__eq__(other):
            if isinstance(other, Named{{TAG_Name}}):
                return self.name == other.name
            return True
        return False

    def __repr__(self):
        return f'{self.__class__.__name__}({super().__repr__()}, "{self.name}")'

    def __dir__(self) -> List[str]:
        return list(set(list(super().__dir__()) + dir(self.value_)))

    def __copy__(self):
        return Named{{TAG_Name}}(self.value_, self.name)

    def __deepcopy__(self, memodict=None):
        return Named{{TAG_Name}}(
            deepcopy(self.value),
            self.name
        )

    def __reduce__(self):
        return Named{{TAG_Name}}, (self.value, self.name)
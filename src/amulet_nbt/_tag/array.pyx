## This file is generated from a template.
## Do not modify this file directly or your changes will get overwritten.
## Edit the accompanying .pyx.tp file instead.

## This file is generated by tempita. Do not modify this file directly or your changes will get overwritten.
## To edit this file edit the template in template/src

import numpy
cimport numpy
numpy.import_array()
from typing import Any, Iterator

from cython.operator cimport dereference
from cpython cimport Py_INCREF
from libc.stdint cimport (
    int8_t,
    int32_t,
    int64_t,
)
from libcpp.memory cimport make_shared
from amulet_nbt._nbt.array cimport Array
from amulet_nbt._nbt cimport TagNode, CByteTag, CIntTag, CLongTag, CByteArrayTag, CIntArrayTag, CLongArrayTag
from amulet_nbt._tag.abc cimport AbstractBaseMutableTag
# from amulet_nbt._const cimport CommaSpace, ID_BYTE_ARRAY, ID_INT_ARRAY, ID_LONG_ARRAY
# from amulet_nbt._dtype import EncoderType


cdef class AbstractBaseArrayTag(AbstractBaseMutableTag):
    @property
    def np_array(AbstractBaseArrayTag self) -> numpy.ndarray:
        """
        A numpy array holding the same internal data.
        Changes to the array will also modify the internal state.
        """
        raise NotImplementedError

    @property
    def py_data(self) -> Any:
        """
        A python representation of the class. Note that the return type is undefined and may change in the future.
        You would be better off using the py_{type} or np_array properties if you require a fixed type.
        This is here for convenience to get a python representation under the same property name.
        """
        return self.np_array

    # Sized
    def __len__(AbstractBaseArrayTag self):
        raise NotImplementedError

    # Sequence
    def __getitem__(AbstractBaseArrayTag self, item):
        raise NotImplementedError

    def __iter__(self):
        raise NotImplementedError

    def __contains__(self, value):
        raise NotImplementedError

    def __reversed__(self):
        raise NotImplementedError

    # MutableSequence
    def __setitem__(AbstractBaseArrayTag self, key, value):
        raise NotImplementedError

    # Array interface
    def __array__(AbstractBaseArrayTag self, dtype=None):
        raise NotImplementedError


cdef class ByteArrayTag(AbstractBaseArrayTag):
    """This class behaves like an 1D Numpy signed integer array with each value stored in a byte."""
    tag_id: int = 7

    def __init__(ByteArrayTag self, object value = ()):
        cdef numpy.ndarray arr = numpy.asarray(value, numpy.dtype("int8")).ravel()
        self.cpp = make_shared[CByteArrayTag](arr.size)
        cdef size_t i
        for i in range(arr.size):
            dereference(self.cpp)[i] = arr[i]

    @staticmethod
    cdef ByteArrayTag wrap(CByteArrayTagPtr cpp):
        cdef ByteArrayTag tag = ByteArrayTag.__new__(ByteArrayTag)
        tag.cpp = cpp
        return tag

    cdef TagNode to_node(self):
        cdef TagNode node
        node.emplace[CByteArrayTagPtr](self.cpp)
        return node

    @property
    def np_array(ByteArrayTag self) -> numpy.ndarray:
        return numpy.asarray(self)

    def __eq__(ByteArrayTag self, object other):
        if not isinstance(other, ByteArrayTag):
            return False
        cdef ByteArrayTag tag = other
        return dereference(self.cpp) == dereference(tag.cpp)

    def __repr__(ByteArrayTag self):
        return f"ByteArrayTag({list(self)})"

    def __str__(ByteArrayTag self):
        return str(list(self))

    def __reduce__(ByteArrayTag self):
        raise NotImplementedError

    def __copy__(ByteArrayTag self):
        raise NotImplementedError

    def __deepcopy__(ByteArrayTag self, memo=None):
        raise NotImplementedError

    # Sized
    def __len__(ByteArrayTag self):
        return dereference(self.cpp).size()

    # Sequence
    def __getitem__(ByteArrayTag self, ptrdiff_t item):
        if item < 0:
            item += dereference(self.cpp).size()
        if item < 0 or item >= dereference(self.cpp).size():
            raise IndexError("ByteArrayTag assignment index out of range")
        return dereference(self.cpp)[item]

    def __iter__(ByteArrayTag self) -> Iterator[int]:
        cdef size_t index
        for index in range(dereference(self.cpp).size()):
            yield dereference(self.cpp)[index]

    def __reversed__(ByteArrayTag self) -> Iterator[int]:
        cdef size_t index
        for index in range(dereference(self.cpp).size() - 1, -1, -1):
            yield dereference(self.cpp)[index]

    def __contains__(ByteArrayTag self, value):
        cdef int8_t tag

        try:
            tag = value
        except TypeError:
            return False

        cdef CByteArrayTag.iterator it = dereference(self.cpp).begin()
        cdef size_t index
        for index in range(dereference(self.cpp).size()):
            if dereference(self.cpp)[index] == tag:
                return True
        return False

    # MutableSequence
    def __setitem__(ByteArrayTag self, ptrdiff_t item, int8_t value):
        if item < 0:
            item += dereference(self.cpp).size()
        if item < 0 or item >= dereference(self.cpp).size():
            raise IndexError("ByteArrayTag assignment index out of range")
        dereference(self.cpp)[item] = value

    # Array interface
    def __array__(ByteArrayTag self, dtype=None):
        cdef numpy.npy_intp shape[1]
        shape[0] = <numpy.npy_intp> dereference(self.cpp).size()
        cdef numpy.ndarray ndarray = numpy.PyArray_SimpleNewFromData(1, shape, numpy.NPY_INT8, dereference(self.cpp).data())
        Py_INCREF(self)
        numpy.PyArray_SetBaseObject(ndarray, self)
        return ndarray
#
#     # cdef str _to_snbt(ByteArrayTag self):
#     #     cdef long long elem
#     #     cdef list tags = []
#     #     for elem in self.cpp:
#     #         tags.append(f"{elem}B")
#     #     return f"[B;{CommaSpace.join(tags)}]"



cdef class IntArrayTag(AbstractBaseArrayTag):
    """This class behaves like an 1D Numpy signed integer array with each value stored in a int."""
    tag_id: int = 11

    def __init__(IntArrayTag self, object value = ()):
        cdef numpy.ndarray arr = numpy.asarray(value, numpy.int32).ravel()
        self.cpp = make_shared[CIntArrayTag](arr.size)
        cdef size_t i
        for i in range(arr.size):
            dereference(self.cpp)[i] = arr[i]

    @staticmethod
    cdef IntArrayTag wrap(CIntArrayTagPtr cpp):
        cdef IntArrayTag tag = IntArrayTag.__new__(IntArrayTag)
        tag.cpp = cpp
        return tag

    cdef TagNode to_node(self):
        cdef TagNode node
        node.emplace[CIntArrayTagPtr](self.cpp)
        return node

    @property
    def np_array(IntArrayTag self) -> numpy.ndarray:
        return numpy.asarray(self)

    def __eq__(IntArrayTag self, object other):
        if not isinstance(other, IntArrayTag):
            return False
        cdef IntArrayTag tag = other
        return dereference(self.cpp) == dereference(tag.cpp)

    def __repr__(IntArrayTag self):
        return f"IntArrayTag({list(self)})"

    def __str__(IntArrayTag self):
        return str(list(self))

    def __reduce__(IntArrayTag self):
        raise NotImplementedError

    def __copy__(IntArrayTag self):
        raise NotImplementedError

    def __deepcopy__(IntArrayTag self, memo=None):
        raise NotImplementedError

    # Sized
    def __len__(IntArrayTag self):
        return dereference(self.cpp).size()

    # Sequence
    def __getitem__(IntArrayTag self, ptrdiff_t item):
        if item < 0:
            item += dereference(self.cpp).size()
        if item < 0 or item >= dereference(self.cpp).size():
            raise IndexError("IntArrayTag assignment index out of range")
        return dereference(self.cpp)[item]

    def __iter__(IntArrayTag self) -> Iterator[int]:
        cdef size_t index
        for index in range(dereference(self.cpp).size()):
            yield dereference(self.cpp)[index]

    def __reversed__(IntArrayTag self) -> Iterator[int]:
        cdef size_t index
        for index in range(dereference(self.cpp).size() - 1, -1, -1):
            yield dereference(self.cpp)[index]

    def __contains__(IntArrayTag self, value):
        cdef int32_t tag

        try:
            tag = value
        except TypeError:
            return False

        cdef CIntArrayTag.iterator it = dereference(self.cpp).begin()
        cdef size_t index
        for index in range(dereference(self.cpp).size()):
            if dereference(self.cpp)[index] == tag:
                return True
        return False

    # MutableSequence
    def __setitem__(IntArrayTag self, ptrdiff_t item, int32_t value):
        if item < 0:
            item += dereference(self.cpp).size()
        if item < 0 or item >= dereference(self.cpp).size():
            raise IndexError("IntArrayTag assignment index out of range")
        dereference(self.cpp)[item] = value

    # Array interface
    def __array__(IntArrayTag self, dtype=None):
        cdef numpy.npy_intp shape[1]
        shape[0] = <numpy.npy_intp> dereference(self.cpp).size()
        cdef numpy.ndarray ndarray = numpy.PyArray_SimpleNewFromData(1, shape, numpy.NPY_INT32, dereference(self.cpp).data())
        Py_INCREF(self)
        numpy.PyArray_SetBaseObject(ndarray, self)
        return ndarray
#
#     # cdef str _to_snbt(IntArrayTag self):
#     #     cdef long long elem
#     #     cdef list tags = []
#     #     for elem in self.cpp:
#     #         tags.append(f"{elem}")
#     #     return f"[I;{CommaSpace.join(tags)}]"



cdef class LongArrayTag(AbstractBaseArrayTag):
    """This class behaves like an 1D Numpy signed integer array with each value stored in a long."""
    tag_id: int = 12

    def __init__(LongArrayTag self, object value = ()):
        cdef numpy.ndarray arr = numpy.asarray(value, numpy.int64).ravel()
        self.cpp = make_shared[CLongArrayTag](arr.size)
        cdef size_t i
        for i in range(arr.size):
            dereference(self.cpp)[i] = arr[i]

    @staticmethod
    cdef LongArrayTag wrap(CLongArrayTagPtr cpp):
        cdef LongArrayTag tag = LongArrayTag.__new__(LongArrayTag)
        tag.cpp = cpp
        return tag

    cdef TagNode to_node(self):
        cdef TagNode node
        node.emplace[CLongArrayTagPtr](self.cpp)
        return node

    @property
    def np_array(LongArrayTag self) -> numpy.ndarray:
        return numpy.asarray(self)

    def __eq__(LongArrayTag self, object other):
        if not isinstance(other, LongArrayTag):
            return False
        cdef LongArrayTag tag = other
        return dereference(self.cpp) == dereference(tag.cpp)

    def __repr__(LongArrayTag self):
        return f"LongArrayTag({list(self)})"

    def __str__(LongArrayTag self):
        return str(list(self))

    def __reduce__(LongArrayTag self):
        raise NotImplementedError

    def __copy__(LongArrayTag self):
        raise NotImplementedError

    def __deepcopy__(LongArrayTag self, memo=None):
        raise NotImplementedError

    # Sized
    def __len__(LongArrayTag self):
        return dereference(self.cpp).size()

    # Sequence
    def __getitem__(LongArrayTag self, ptrdiff_t item):
        if item < 0:
            item += dereference(self.cpp).size()
        if item < 0 or item >= dereference(self.cpp).size():
            raise IndexError("LongArrayTag assignment index out of range")
        return dereference(self.cpp)[item]

    def __iter__(LongArrayTag self) -> Iterator[int]:
        cdef size_t index
        for index in range(dereference(self.cpp).size()):
            yield dereference(self.cpp)[index]

    def __reversed__(LongArrayTag self) -> Iterator[int]:
        cdef size_t index
        for index in range(dereference(self.cpp).size() - 1, -1, -1):
            yield dereference(self.cpp)[index]

    def __contains__(LongArrayTag self, value):
        cdef int64_t tag

        try:
            tag = value
        except TypeError:
            return False

        cdef CLongArrayTag.iterator it = dereference(self.cpp).begin()
        cdef size_t index
        for index in range(dereference(self.cpp).size()):
            if dereference(self.cpp)[index] == tag:
                return True
        return False

    # MutableSequence
    def __setitem__(LongArrayTag self, ptrdiff_t item, int64_t value):
        if item < 0:
            item += dereference(self.cpp).size()
        if item < 0 or item >= dereference(self.cpp).size():
            raise IndexError("LongArrayTag assignment index out of range")
        dereference(self.cpp)[item] = value

    # Array interface
    def __array__(LongArrayTag self, dtype=None):
        cdef numpy.npy_intp shape[1]
        shape[0] = <numpy.npy_intp> dereference(self.cpp).size()
        cdef numpy.ndarray ndarray = numpy.PyArray_SimpleNewFromData(1, shape, numpy.NPY_INT64, dereference(self.cpp).data())
        Py_INCREF(self)
        numpy.PyArray_SetBaseObject(ndarray, self)
        return ndarray
#
#     # cdef str _to_snbt(LongArrayTag self):
#     #     cdef long long elem
#     #     cdef list tags = []
#     #     for elem in self.cpp:
#     #         tags.append(f"{elem}L")
#     #     return f"[L;{CommaSpace.join(tags)}]"


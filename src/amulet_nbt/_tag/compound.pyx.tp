{{py:import base64}}
{{base64.b64decode("IyMgVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGEgdGVtcGxhdGUuCiMjIERvIG5vdCBtb2RpZnkgdGhpcyBmaWxlIGRpcmVjdGx5IG9yIHlvdXIgY2hhbmdlcyB3aWxsIGdldCBvdmVyd3JpdHRlbi4KIyMgRWRpdCB0aGUgYWNjb21wYW55aW5nIC5weXgudHAgZmlsZSBpbnN0ZWFkLg==").decode()}}
# distutils: language = c++
# distutils: extra_compile_args = -std=c++20 /std:c++20
# distutils: extra_link_args = -std=c++20 /std:c++20
# cython: c_string_type=str, c_string_encoding=utf8

from collections.abc import Mapping, Iterable, KeysView, ItemsView, ValuesView

from libcpp.string cimport string
from libcpp cimport bool
from cython.operator cimport dereference, postincrement

from amulet_nbt._nbt cimport CCompoundTag, CCompoundTagPtr, CIntTag, TagNode
from amulet_nbt._libcpp.variant cimport get
from amulet_nbt._tag.abc cimport AbstractBaseTag, AbstractBaseMutableTag

from amulet_nbt._nbt cimport (
    CByteTag,
    CShortTag,
    CIntTag,
    CLongTag,
    CFloatTag,
    CDoubleTag,
    CStringTag,
    CListTag,
    CCompoundTag,
    CByteArrayTag,
    CIntArrayTag,
    CLongArrayTag,
    CListTagPtr,
    CCompoundTagPtr,
    CByteArrayTagPtr,
    CIntArrayTagPtr,
    CLongArrayTagPtr,
    CByteList,
    CShortList,
    CIntList,
    CLongList,
    CFloatList,
    CDoubleList,
    CByteArrayList,
    CStringList,
    CListList,
    CCompoundList,
    CIntArrayList,
    CLongArrayList,
    TagNode,
)

from .int cimport ByteTag, ShortTag, IntTag, LongTag
from .float cimport FloatTag, DoubleTag
from .string cimport StringTag
from .list cimport is_list_eq, ListTag
from .array cimport ByteArrayTag, IntArrayTag, LongArrayTag

{{py:
ClassData = (
    #id,  C cls,           C node cls          C list cls        py cls,         tag var,          list var
    (1,  "CByteTag",      "CByteTag",         "CByteList",      "ByteTag",      "byte_tag",       "byte_list",       ),
    (2,  "CShortTag",     "CShortTag",        "CShortList",     "ShortTag",     "short_tag",      "short_list",      ),
    (3,  "CIntTag",       "CIntTag",          "CIntList",       "IntTag",       "int_tag",        "int_list",        ),
    (4,  "CLongTag",      "CLongTag",         "CLongList",      "LongTag",      "long_tag",       "long_list",       ),
    (5,  "CFloatTag",     "CFloatTag",        "CFloatList",     "FloatTag",     "float_tag",      "float_list",      ),
    (6,  "CDoubleTag",    "CDoubleTag",       "CDoubleList",    "DoubleTag",    "double_tag",     "double_list",     ),
    (7,  "CByteArrayTag", "CByteArrayTagPtr", "CByteArrayList", "ByteArrayTag", "byte_array_tag", "byte_array_list", ),
    (8,  "CStringTag",    "CStringTag",       "CStringList",    "StringTag",    "string_tag",     "string_list",     ),
    (9,  "CListTag",      "CListTagPtr",      "CListList",      "ListTag",      "list_tag",       "list_list",       ),
    (10, "CCompoundTag",  "CCompoundTagPtr",  "CCompoundList",  "CompoundTag",  "compound_tag",   "compound_list",   ),
    (11, "CIntArrayTag",  "CIntArrayTagPtr",  "CIntArrayList",  "IntArrayTag",  "int_array_tag",  "int_array_list",  ),
    (12, "CLongArrayTag", "CLongArrayTagPtr", "CLongArrayList", "LongArrayTag", "long_array_tag", "long_array_list", ),
)
}}


{{
"\n\n\n".join(
f"""cdef inline bool _is_{tag_var}_node_eq(TagNode* a, TagNode* b) noexcept nogil:
    if dereference(b).index() != {index}:
        return False
    
    return {
        f"is_list_eq(get[{c_node_cls}](dereference(a)), get[{c_node_cls}](dereference(b)))" if index == 9 else
        f"is_compound_eq(get[{c_node_cls}](dereference(a)), get[{c_node_cls}](dereference(b)))" if index == 10 else
        f"dereference(get[{c_node_cls}](dereference(a))) == dereference(get[{c_node_cls}](dereference(b)))" if index in {7, 11, 12} else
        f"get[{c_node_cls}](dereference(a)) == get[{c_node_cls}](dereference(b))"
    }"""
        for index, c_cls, c_node_cls, c_list_cls, py_cls, tag_var, list_var in ClassData
    )
}}


cdef bool is_compound_eq(CCompoundTagPtr a, CCompoundTagPtr b) noexcept nogil:
    if dereference(a).size() != dereference(b).size():
        return False

    cdef CCompoundTag.iterator it1 = dereference(a).begin()
    cdef CCompoundTag.iterator it2
    cdef string key
    cdef TagNode* node
    cdef size_t node_index

    while it1 != dereference(a).end():
        key = dereference(it1).first
        it2 = dereference(b).find(key)
        if it2 == dereference(b).end():
            return False
        node = &dereference(it1).second
        node_index = dereference(node).index()
{{
"\n".join(
f"""        {"el"*(index!=1)}if node_index == {index}:
            return _is_{tag_var}_node_eq(node, &dereference(it2).second)"""
    for index, c_cls, c_node_cls, c_list_cls, py_cls, tag_var, list_var in ClassData
)
}}
        postincrement(it1)
    return True


cdef AbstractBaseTag wrap_node(TagNode* node):
    cdef size_t index = dereference(node).index()
{{
"\n".join(
f"""    {"el"*(index!=1)}if index == {index}:
        return {py_cls}.wrap(get[{c_node_cls}](dereference(node)))"""
    for index, c_cls, c_node_cls, c_list_cls, py_cls, tag_var, list_var in ClassData
)
}}
    else:
        raise RuntimeError


cdef class CompoundTag(AbstractBaseMutableTag):
    """
    A Python wrapper around a C++ unordered map.
    Note that this class is not thread safe and inherits all the limitations of a C++ unordered_map.
    """
    tag_id: int = 10

    def __init__(self, *args, **kwargs) -> None:
        self.update(*args, **kwargs)

    @staticmethod
    cdef CompoundTag wrap(CCompoundTagPtr cpp):
        cdef CompoundTag tag = CompoundTag.__new__(CompoundTag)
        tag.cpp = cpp
        return tag

    cdef TagNode to_node(self):
        cdef TagNode node
        node.emplace[CCompoundTagPtr](self.cpp)
        return node

    def __eq__(CompoundTag self, object other):
        if not isinstance(other, CompoundTag):
            return False
        cdef CompoundTag tag = other
        return is_compound_eq(self.cpp, tag.cpp)

    # Sized
    def __len__(self) -> size_t:
        return dereference(self.cpp).size()

    # Iterable
    def __iter__(self) -> Iterable[str | bytes]:
        cdef list keys = []
        cdef CCompoundTag.iterator it = dereference(self.cpp).begin()
        cdef string key
        while it != dereference(self.cpp).end():
            key = dereference(it).first
            try:
                yield key
            except UnicodeDecodeError as e:
                yield <bytes>key
            postincrement(it)
        return keys

    # Mapping
    def __getitem__(self, string key) -> AbstractBaseTag:
        cdef CCompoundTag.iterator it = dereference(self.cpp).find(key)

        if it == dereference(self.cpp).end():
            raise KeyError(key)

        return wrap_node(&dereference(it).second)

    def get(self, string key, object default = None, object cls = AbstractBaseTag):
        cdef CCompoundTag.iterator it = dereference(self.cpp).find(key)

        if it == dereference(self.cpp).end():
            if default is None:
                raise KeyError(key)
            else:
                return default

        cdef AbstractBaseTag tag = wrap_node(&dereference(it).second)
        if isinstance(tag, cls):
            return tag
        elif default is None:
            raise TypeError(f"Expected tag to be of type {cls.__name__} but got {type(tag).__name__}")
        else:
            return default

    def __contains__(self, string key):
        return dereference(self.cpp).contains(key)

    def keys(self):
        return KeysView(self)

    def items(self):
        return ItemsView(self)

    def values(self):
        return ValuesView(self)

    # MutableMapping
    def __setitem__(self, string key, AbstractBaseTag tag not None) -> None:
        dereference(self.cpp)[<string> key] = tag.to_node()

    def __delitem__(self, string key) -> None:
        dereference(self.cpp).erase(key)

    __marker = object()

    def pop(self, string key, default=__marker):
        '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
          If key is not found, d is returned if given, otherwise KeyError is raised.
        '''
        cdef CCompoundTag.iterator it = dereference(self.cpp).find(key)
        if it == dereference(self.cpp).end():
            if default is self.__marker:
                raise KeyError(key)
            else:
                return default

        cdef AbstractBaseTag tag = wrap_node(&dereference(it).second)
        dereference(self.cpp).erase(it)
        return tag

    def popitem(self):
        '''D.popitem() -> (k, v), remove and return some (key, value) pair
           as a 2-tuple; but raise KeyError if D is empty.
        '''
        cdef CCompoundTag.iterator it = dereference(self.cpp).begin()
        if it == dereference(self.cpp).end():
            raise KeyError

        cdef string key = dereference(it).first
        cdef AbstractBaseTag tag = wrap_node(&dereference(it).second)
        dereference(self.cpp).erase(it)
        return key, tag

    def clear(self):
        dereference(self.cpp).clear()

    def update(self, other=(), /, **kwds):
        ''' D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
            If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
            If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
            In either case, this is followed by: for k, v in F.items(): D[k] = v
        '''
        if isinstance(other, Mapping):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, "keys"):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    def setdefault(self, string key, AbstractBaseTag tag not None, object cls = AbstractBaseTag):
        cdef CCompoundTag.iterator it = dereference(self.cpp).find(key)

        if it == dereference(self.cpp).end():
            # if the key does not exist then set it
            self[key] = tag
            return tag

        cdef AbstractBaseTag existing_tag = wrap_node(&dereference(it).second)

        if not isinstance(tag, cls):
            # if the key exists but has the wrong type then set it
            self[key] = tag
            return tag

        return existing_tag

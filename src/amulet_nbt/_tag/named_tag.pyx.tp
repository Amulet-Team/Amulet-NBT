{{py:
import base64
from template import include
}}
{{base64.b64decode("IyMgVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGEgdGVtcGxhdGUuCiMjIERvIG5vdCBtb2RpZnkgdGhpcyBmaWxlIGRpcmVjdGx5IG9yIHlvdXIgY2hhbmdlcyB3aWxsIGdldCBvdmVyd3JpdHRlbi4KIyMgRWRpdCB0aGUgYWNjb21wYW55aW5nIC5weXgudHAgZmlsZSBpbnN0ZWFkLg==").decode()}}
# cython: language_level=3, boundscheck=False, wraparound=False
# distutils: language = c++
# distutils: extra_compile_args = -std=c++20 /std:c++20
# distutils: extra_link_args = -std=c++20 /std:c++20
# cython: c_string_type=str, c_string_encoding=utf8

import copy
import gzip
from libcpp.string cimport string
from libcpp cimport bool
from amulet_nbt._libcpp.endian cimport endian
from amulet_nbt._string_encoding cimport StringEncoding
from amulet_nbt._string_encoding import mutf8_encoding
from amulet_nbt._string_encoding._cpp cimport CStringEncode
from amulet_nbt._nbt_encoding._binary cimport write_named_tag
from amulet_nbt._nbt_encoding._binary.encoding_preset cimport EncodingPreset

from .abc cimport AbstractBase, AbstractBaseTag
from .int cimport ByteTag, ShortTag, IntTag, LongTag
from .float cimport FloatTag, DoubleTag
from .string cimport StringTag
from .list cimport ListTag
from .compound cimport wrap_node, CompoundTag
from .array cimport ByteArrayTag, IntArrayTag, LongArrayTag


cdef class NamedTag(AbstractBase):
    def __init__(self, AbstractBaseTag tag = None, string name = b""):
        if tag is None:
            tag = CompoundTag()
        self.tag_node = tag.to_node()
        self.tag_name = name

    @property
    def tag(self) -> AbstractBaseTag:
        return wrap_node(&self.tag_node)

    @tag.setter
    def tag(self, AbstractBaseTag tag not None):
        self.tag_node = tag.to_node()

    @property
    def name(self) -> str | bytes:
        try:
            return <str> self.tag_name
        except UnicodeDecodeError as e:
            return <bytes> self.tag_name

    @name.setter
    def name(self, name):
        self.tag_name = name

    def to_nbt(
        self,
        *,
        EncodingPreset preset = None,
        bool compressed=True,
        bool little_endian=False,
        string_encoding: StringEncoding = mutf8_encoding,
    ):
        """
        Get the data in binary NBT format.

        :param preset: A class containing compression, endianness and encoding presets.
        :param compressed: Should the bytes be compressed with gzip.
        :param little_endian: Should the bytes be saved in little endian format.
        :param string_encoding: A function to encode strings to bytes.
        :param name: The root tag name.
        :return: The binary NBT representation of the class.
        """
        cdef endian endianness

        if preset is not None:
            endianness = preset.endianness
            compressed = preset.compressed
            string_encoding = preset.string_encoding
        else:
            endianness = endian.little if little_endian else endian.big

        cdef bytes data = self.write_tag(
            endianness,
            string_encoding.encode_cpp
        )

        if compressed:
            return gzip.compress(data)
        return data

    cdef string write_tag(self, endian endianness, CStringEncode string_encode):
        return write_named_tag[TagNode](self.tag_name, self.tag_node, endianness, string_encode)

    def __eq__(self, other):
        cdef NamedTag other_
        if isinstance(other, NamedTag):
            other_ = other
            return self.name == other_.name and self.tag == other_.tag
        return NotImplemented

    def __repr__(self):
        return f'NamedTag({self.tag!r}, "{self.name}")'

    def __reduce__(self):
        return NamedTag, (self.tag, self.name)

    def __copy__(self):
        return NamedTag(self.tag, self.name)

    def __deepcopy__(self, memodict={}):
        return NamedTag(
            copy.deepcopy(self.tag),
            self.name
        )

    def __getitem__(self, ptrdiff_t item):
        if item < 0:
            item += 2
        if not 0 <= item <= 1:
            raise IndexError("Index out of range")
        return (self.name, self.tag)[item]

    def __iter__(self):
        yield self.name
        yield self.tag

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="ByteTag", tag_name="byte")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="ShortTag", tag_name="short")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="IntTag", tag_name="int")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="LongTag", tag_name="long")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="FloatTag", tag_name="float")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="DoubleTag", tag_name="double")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="StringTag", tag_name="string")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="ListTag", tag_name="list")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="CompoundTag", tag_name="compound")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="ByteArrayTag", tag_name="byte_array")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="IntArrayTag", tag_name="int_array")}}

{{include("amulet_nbt/tpf/NamedTagGet.pyx.tpf", py_cls="LongArrayTag", tag_name="long_array")}}

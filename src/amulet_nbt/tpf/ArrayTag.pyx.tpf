{{py:
from template import include
}}
cdef class {{dtype.capitalize()}}ArrayTag(AbstractBaseArrayTag):
    """This class behaves like an 1D Numpy signed integer array with each value stored in a {{dtype}}."""
    # tag_id = ID_{{dtype.upper()}}_ARRAY

    def __init__({{dtype.capitalize()}}ArrayTag self, object value = ()):
        cdef numpy.ndarray arr = numpy.asarray(value, {{native_data_type}}).ravel()
        self.cpp = make_shared[C{{dtype.capitalize()}}ArrayTag](arr.size)
        cdef size_t i
        for i in range(arr.size):
            dereference(self.cpp)[i] = arr[i]

    @staticmethod
    cdef {{dtype.capitalize()}}ArrayTag wrap(C{{dtype.capitalize()}}ArrayTagPtr cpp):
        cdef {{dtype.capitalize()}}ArrayTag tag = {{dtype.capitalize()}}ArrayTag.__new__({{dtype.capitalize()}}ArrayTag)
        tag.cpp = cpp
        return tag

    cdef TagNode to_node(self):
        cdef TagNode node
        node.emplace[C{{dtype.capitalize()}}ArrayTagPtr](self.cpp)
        return node

    @property
    def np_array({{dtype.capitalize()}}ArrayTag self) -> numpy.ndarray:
        return numpy.asarray(self)

    def __eq__({{dtype.capitalize()}}ArrayTag self, object other):
        if not isinstance(other, {{dtype.capitalize()}}ArrayTag):
            return False
        cdef {{dtype.capitalize()}}ArrayTag tag = other
        return dereference(self.cpp) == dereference(tag.cpp)

    def __repr__({{dtype.capitalize()}}ArrayTag self):
        return f"{{dtype.capitalize()}}ArrayTag({list(self)})"

    def __str__({{dtype.capitalize()}}ArrayTag self):
        return str(list(self))

    def __reduce__({{dtype.capitalize()}}ArrayTag self):
        raise NotImplementedError

    def __copy__({{dtype.capitalize()}}ArrayTag self):
        raise NotImplementedError

    def __deepcopy__({{dtype.capitalize()}}ArrayTag self, memo=None):
        raise NotImplementedError

    # Sized
    def __len__({{dtype.capitalize()}}ArrayTag self):
        return dereference(self.cpp).size()

    # Sequence
    def __getitem__({{dtype.capitalize()}}ArrayTag self, ptrdiff_t item):
        if item < 0:
            item += dereference(self.cpp).size()
        if item < 0 or item >= dereference(self.cpp).size():
            raise IndexError("{{dtype.capitalize()}}ArrayTag assignment index out of range")
        return dereference(self.cpp)[item]

    def __iter__({{dtype.capitalize()}}ArrayTag self) -> Iterator[int]:
        cdef size_t index
        for index in range(dereference(self.cpp).size()):
            yield dereference(self.cpp)[index]

    def __reversed__({{dtype.capitalize()}}ArrayTag self) -> Iterator[int]:
        cdef size_t index
        for index in range(dereference(self.cpp).size() - 1, -1, -1):
            yield dereference(self.cpp)[index]

    def __contains__({{dtype.capitalize()}}ArrayTag self, value):
        cdef {{cpp}} tag

        try:
            tag = value
        except TypeError:
            return False

        cdef C{{dtype.capitalize()}}ArrayTag.iterator it = dereference(self.cpp).begin()
        cdef size_t index
        for index in range(dereference(self.cpp).size()):
            if dereference(self.cpp)[index] == tag:
                return True
        return False

    # MutableSequence
    def __setitem__({{dtype.capitalize()}}ArrayTag self, ptrdiff_t item, {{cpp}} value):
        if item < 0:
            item += dereference(self.cpp).size()
        if item < 0 or item >= dereference(self.cpp).size():
            raise IndexError("{{dtype.capitalize()}}ArrayTag assignment index out of range")
        dereference(self.cpp)[item] = value

    # Array interface
    def __array__({{dtype.capitalize()}}ArrayTag self, dtype=None):
        cdef numpy.npy_intp shape[1]
        shape[0] = <numpy.npy_intp> dereference(self.cpp).size()
        cdef numpy.ndarray ndarray = numpy.PyArray_SimpleNewFromData(1, shape, numpy.{{npy_c}}, dereference(self.cpp).data())
        Py_INCREF(self)
        numpy.PyArray_SetBaseObject(ndarray, self)
        return ndarray
#
#     # cdef str _to_snbt({{dtype.capitalize()}}ArrayTag self):
#     #     cdef long long elem
#     #     cdef list tags = []
#     #     for elem in self.cpp:
#     #         tags.append(f"{elem}{{snbt_suffix}}")
#     #     return f"[{{snbt_prefix}};{CommaSpace.join(tags)}]"

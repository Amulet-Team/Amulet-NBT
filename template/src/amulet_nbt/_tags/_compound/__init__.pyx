## This file is generated by tempita. Do not modify this file directly or your changes will get overwritten.
## To edit this file edit the template in template/src

from io import BytesIO
import re
from typing import Iterator, Dict, Type, TypeVar
from copy import copy, deepcopy
from collections.abc import MutableMapping
import sys
import warnings

from amulet_nbt._tags._value cimport AbstractBaseTag, AbstractBaseMutableTag
from amulet_nbt._const cimport ID_END, ID_COMPOUND, CommaSpace, CommaNewline
from amulet_nbt._dtype import AnyNBT, DecoderType, EncoderType
from amulet_nbt._tags._numeric._int cimport (
    ByteTag,
    ShortTag,
    IntTag,
    LongTag,
)
from amulet_nbt._tags._numeric._float cimport (
    FloatTag,
    DoubleTag,
)
from amulet_nbt._tags._array cimport (
    ByteArrayTag,
    IntArrayTag,
    LongArrayTag,
)
from amulet_nbt._tags._string cimport StringTag
from amulet_nbt._tags._list cimport ListTag
{{py:from template import include}}

NON_QUOTED_KEY = re.compile('[A-Za-z0-9._+-]+')

T = TypeVar("T")


cdef inline void _check_dict(dict value) except *:
    cdef str key
    cdef AbstractBaseTag val
    for key, val in value.items():
        if key is None or val is None:
            raise TypeError()


cdef class CompoundTag(AbstractBaseMutableTag):
    """
    This class behaves like a python dictionary.
    All keys must be strings and all values must be NBT data types.
    """
    tag_id = ID_COMPOUND

    def __init__(CompoundTag self, object value = (), **kwargs):
        cdef dict dict_value = dict(value, **kwargs)
        _check_dict(dict_value)
        self.value_ = dict_value

    @classmethod
    def create(cls, object value = (), **kwargs) -> CompoundTag:
        return cls(value, **kwargs)

{{include("AbstractBaseMutableTag.pyx", cls_name="CompoundTag")}}

    @property
    def py_dict(CompoundTag self) -> Dict[str, AnyNBT]:
        """
        A python dictionary representation of the class.
        The returned list is a shallow copy of the class, meaning changes will not mirror the instance.
        Use the public API to modify the internal data.
        """
        return copy(self.value_)

    @property
    def py_data(self):
        """
        A python representation of the class. Note that the return type is undefined and may change in the future.
        You would be better off using the py_{type} or np_array properties if you require a fixed type.
        This is here for convenience to get a python representation under the same property name.
        """
        return self.py_dict

    @staticmethod
    def fromkeys(object keys, AbstractBaseTag value=None):
        return CompoundTag(dict.fromkeys(keys, value))

    cdef str _to_snbt(CompoundTag self):
        cdef str name
        cdef AbstractBaseTag elem
        cdef list tags = []
        for name in sorted(self.value_, key=lambda k: (k.lower(), k.swapcase())):
            elem = self.value_[name]
            if NON_QUOTED_KEY.fullmatch(name) is None:
                tags.append(f'"{name}": {elem.to_snbt()}')
            else:
                tags.append(f'{name}: {elem.to_snbt()}')
        return f"{{start_braces}}{CommaSpace.join(tags)}{{end_braces}}"

    cdef str _pretty_to_snbt(CompoundTag self, str indent_chr, int indent_count=0, bint leading_indent=True):
        cdef str name
        cdef AbstractBaseTag elem
        cdef list tags = []
        for name in sorted(self.value_, key=lambda k: (k.lower(), k.swapcase())):
            elem = self.value_[name]
            tags.append(f'{indent_chr * (indent_count + 1)}"{name}": {elem._pretty_to_snbt(indent_chr, indent_count + 1, False)}')
        if tags:
            return f"{indent_chr * indent_count * leading_indent}{{start_braces}}\n{CommaNewline.join(tags)}\n{indent_chr * indent_count}{{end_braces}}"
        else:
            return f"{indent_chr * indent_count * leading_indent}{{start_braces}}{{end_braces}}"

    def __repr__(CompoundTag self):
        return f"{self.__class__.__name__}({repr(self.value_)})"

    def __getitem__(CompoundTag self, str key not None) -> AbstractBaseTag:
        return self.value_[key]

    def __setitem__(CompoundTag self, str key not None, AbstractBaseTag value not None):
        self.value_[key] = value

    def __delitem__(CompoundTag self, str key not None):
        self.value_.__delitem__(key)

    def __iter__(CompoundTag self) -> Iterator[str]:
        yield from self.value_

    def __len__(CompoundTag self) -> int:
        return self.value_.__len__()

{{include("CompoundGetSetdefault.pyx", tag_cls_name="ByteTag", tag_name="byte")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="ShortTag", tag_name="short")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="IntTag", tag_name="int")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="LongTag", tag_name="long")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="FloatTag", tag_name="float")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="DoubleTag", tag_name="double")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="StringTag", tag_name="string")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="ListTag", py_tag_cls_name="ListTag.create", tag_name="list")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="CompoundTag", py_tag_cls_name="CompoundTag", tag_name="compound")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="ByteArrayTag", tag_name="byte_array")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="IntArrayTag", tag_name="int_array")}}
{{include("CompoundGetSetdefault.pyx", tag_cls_name="LongArrayTag", tag_name="long_array")}}
